Having an issue where both instances are the server role. 
Fixed the issue by setting both to a hard coded static port,
but would need more time to fix issue with random ports 
Could also fix the issue by adding a feature to choose if you are the server 
or the client before it tries to bind and then if it is the client let you 
type the server port to bind to  

Accomplished implementing necessary features and creating clear comments 
Accomplished implementing the following features 

Features Implemented: 
1. Create a single network program 
2. Hard code a random ephemeral port (20000 to 50000; if you get a bind error on the first run try another)
3. When the program starts, have it try to open a listening socket as if it’s a server (bind(), listen(), accept())
If the call to bind() fails with an error, have the program assume another instance of the program is already running and instead use connect() to connect to the existing socket
4. Run two copies of the program (separate windows) to verify that they connect as expected
 The program that successfully binds should only accept one connection (close the listenfd after successful Accept and use the “clientfd” which is more appropriately named “peerfd” at that point).
5. Once connected, each program should behave the same way (they’re peers), have each program send an pre-written greeting on the peer socket, and have each program read and print the contents to the screen (prefaced by <peer>)
6. Have each program accept terminal input (it can block while waiting for input)
7. Send the input on the socket, then check/wait for input on the socket and print what arrives
8. If either program is closed (such as via ctrl+c) have the other print “peer disconnected: exiting” after trying to send a message on the closed socket (which generated by SIGPIPE). Close descriptors and such
9. Have the programs intercept the Ctrl+C signal and ask the user to confirm whether they want to close the program by typing y or n and respond accordingly (clean up appropriately)
10. Had to add extra print statements for debugging and clarity 

How it works:

The program starts by attempting to bind to an ephemeral port (hard-coded). If binding is successful, the program acts as a server, listening for incoming connections. If binding fails, the program assumes another instance is already running and attempts to connect to that instance as a client.

Once two instances are connected, they both send a greeting message to each other. After that, they enter a loop where they continuously receive messages from their connected peer and allow the user to send messages to the peer. Messages are displayed on the console as they are received.

The program can be terminated by the user, which will close the socket connection and exit. 

How to run: 
1. Compile the program compile.scr which calls the following script 
    gcc -o sockets sockets.c

2. Run two instances of the compiled program in separate terminal windows on the same machine. The first instance will act as a server, and the second instance will act as a client:

    Terminal 1 (Server):
compile.scr 
sockets 

    Terminal 2 (Client):
sockets 

3. Once both instances are connected, you can start sending messages between them by typing the message and pressing Enter.

4. To exit the program, press Ctrl+C and you will be prompted to type “y” if you want to exit
